{
  "schemaVersion": "1.0.0",
  "readme": "",
  "modules": [
    {
      "kind": "javascript-module",
      "path": "locales/locales.js",
      "declarations": [
        {
          "kind": "variable",
          "name": "sourceLocale",
          "default": "`en`",
          "description": "The locale code that templates in this source code are written in."
        },
        {
          "kind": "variable",
          "name": "targetLocales",
          "type": {
            "text": "array"
          },
          "default": "[ , ]",
          "description": "The other locale codes that this application is localized into. Sorted\nlexicographically."
        },
        {
          "kind": "variable",
          "name": "allLocales",
          "type": {
            "text": "array"
          },
          "default": "[ `en`, ]",
          "description": "All valid project locale codes. Sorted lexicographically."
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "sourceLocale",
          "declaration": {
            "name": "sourceLocale",
            "module": "locales/locales.js"
          }
        },
        {
          "kind": "js",
          "name": "targetLocales",
          "declaration": {
            "name": "targetLocales",
            "module": "locales/locales.js"
          }
        },
        {
          "kind": "js",
          "name": "allLocales",
          "declaration": {
            "name": "allLocales",
            "module": "locales/locales.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "src/context.ts",
      "declarations": [
        {
          "kind": "variable",
          "name": "messengerStoreContext"
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "messengerStoreContext",
          "declaration": {
            "name": "messengerStoreContext",
            "module": "src/context.ts"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "src/index.ts",
      "declarations": [],
      "exports": [
        {
          "kind": "js",
          "name": "*",
          "declaration": {
            "name": "*",
            "package": "./messenger-store.js"
          }
        },
        {
          "kind": "js",
          "name": "*",
          "declaration": {
            "name": "*",
            "package": "./messenger-client.js"
          }
        },
        {
          "kind": "js",
          "name": "*",
          "declaration": {
            "name": "*",
            "package": "./context.js"
          }
        },
        {
          "kind": "js",
          "name": "*",
          "declaration": {
            "name": "*",
            "package": "./types.js"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "src/message-set.ts",
      "declarations": [
        {
          "kind": "variable",
          "name": "MESSAGE_SET_TIMEFRAME_INTERVAL"
        },
        {
          "kind": "function",
          "name": "orderInMessageSets",
          "return": {
            "type": {
              "text": "Array<MessageSet<T>>"
            }
          },
          "parameters": [
            {
              "name": "messages",
              "type": {
                "text": "Record<EntryHashB64, Signed<T>>"
              }
            },
            {
              "name": "agentSets",
              "type": {
                "text": "Array<Array<AgentPubKey>>"
              }
            }
          ]
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "MESSAGE_SET_TIMEFRAME_INTERVAL",
          "declaration": {
            "name": "MESSAGE_SET_TIMEFRAME_INTERVAL",
            "module": "src/message-set.ts"
          }
        },
        {
          "kind": "js",
          "name": "orderInMessageSets",
          "declaration": {
            "name": "orderInMessageSets",
            "module": "src/message-set.ts"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "src/messenger-client.ts",
      "declarations": [
        {
          "kind": "class",
          "description": "",
          "name": "MessengerClient",
          "members": [
            {
              "kind": "method",
              "name": "queryPrivateMessengerEntries",
              "return": {
                "type": {
                  "text": "Promise<\n\t\tRecord<EntryHashB64, PrivateMessengerEntry>\n\t>"
                }
              }
            },
            {
              "kind": "method",
              "name": "sendPeerMessage",
              "parameters": [
                {
                  "name": "recipient",
                  "type": {
                    "text": "AgentPubKey"
                  }
                },
                {
                  "name": "message",
                  "type": {
                    "text": "Message"
                  }
                }
              ],
              "description": "Peer Chat"
            },
            {
              "kind": "method",
              "name": "markPeerMessagesAsRead",
              "parameters": [
                {
                  "name": "peer",
                  "type": {
                    "text": "AgentPubKey"
                  }
                },
                {
                  "name": "readMessagesHashes",
                  "type": {
                    "text": "Array<EntryHash>"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "createGroupChat",
              "return": {
                "type": {
                  "text": "Promise<EntryHash>"
                }
              },
              "parameters": [
                {
                  "name": "group",
                  "type": {
                    "text": "Group"
                  }
                }
              ],
              "description": "Group Chat"
            },
            {
              "kind": "method",
              "name": "sendGroupMessage",
              "parameters": [
                {
                  "name": "originalGroupHash",
                  "type": {
                    "text": "EntryHash"
                  }
                },
                {
                  "name": "currentGroupHash",
                  "type": {
                    "text": "EntryHash"
                  }
                },
                {
                  "name": "message",
                  "type": {
                    "text": "Message"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "markGroupMessagesAsRead",
              "parameters": [
                {
                  "name": "groupHash",
                  "type": {
                    "text": "EntryHash"
                  }
                },
                {
                  "name": "readMessagesHashes",
                  "type": {
                    "text": "Array<EntryHash>"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "sendPeerChatTypingIndicator",
              "parameters": [
                {
                  "name": "peerAgentSet",
                  "type": {
                    "text": "AgentPubKey[]"
                  }
                }
              ],
              "description": "Typing Indicator"
            },
            {
              "kind": "method",
              "name": "sendGroupChatTypingIndicator",
              "parameters": [
                {
                  "name": "groupHash",
                  "type": {
                    "text": "EntryHash"
                  }
                },
                {
                  "name": "allMembersAgentsSets",
                  "type": {
                    "text": "Array<Array<AgentPubKey>>"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "synchronizeWithLinkedDevice",
              "parameters": [
                {
                  "name": "linkedDevice",
                  "type": {
                    "text": "AgentPubKey"
                  }
                }
              ],
              "description": "Linked Devices"
            }
          ],
          "superclass": {
            "name": "ZomeClient",
            "package": "@tnesh-stack/utils"
          }
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "MessengerClient",
          "declaration": {
            "name": "MessengerClient",
            "module": "src/messenger-client.ts"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "src/messenger-store.ts",
      "declarations": [
        {
          "kind": "class",
          "description": "",
          "name": "MessengerStore",
          "members": [
            {
              "kind": "field",
              "name": "peerIsTyping",
              "privacy": "private",
              "default": "new MemoHoloHashMap((agent: AgentPubKey) => { const peerIsTyping = new Signal.State<boolean>(false); let timeout: any; this.client.onSignal(signal => { if (signal.type === 'PeerChatTypingIndicator') { if (encodeHashToBase64(signal.peer) === encodeHashToBase64(agent)) { peerIsTyping.set(true); if (timeout) clearTimeout(timeout); timeout = setTimeout(() => { peerIsTyping.set(false); }, TYPING_INDICATOR_TTL_MS); } } else if ( signal.type === 'EntryCreated' && signal.app_entry.type === 'PrivateMessengerEntry' && signal.app_entry.signed_content.content.type === 'PeerMessage' ) { if ( encodeHashToBase64(signal.app_entry.provenance) === encodeHashToBase64(agent) ) { peerIsTyping.set(false); if (timeout) clearTimeout(timeout); } } }); return peerIsTyping; })"
            },
            {
              "kind": "field",
              "name": "peerIsTypingInGroup",
              "privacy": "private",
              "default": "new MemoHoloHashMap( (groupHash: EntryHash) => new MemoHoloHashMap((agent: AgentPubKey) => { const peerIsTyping = new Signal.State<boolean>(false); let timeout: any; this.client.onSignal(signal => { if (signal.type === 'GroupChatTypingIndicator') { if ( encodeHashToBase64(signal.peer) === encodeHashToBase64(agent) && encodeHashToBase64(signal.group_hash) === encodeHashToBase64(groupHash) ) { peerIsTyping.set(true); if (timeout) clearTimeout(timeout); timeout = setTimeout(() => { peerIsTyping.set(false); }, TYPING_INDICATOR_TTL_MS); } } else if ( signal.type === 'EntryCreated' && signal.app_entry.type === 'PrivateMessengerEntry' && signal.app_entry.signed_content.content.type === 'GroupMessage' ) { if ( encodeHashToBase64(signal.app_entry.provenance) === encodeHashToBase64(agent) && encodeHashToBase64( signal.app_entry.signed_content.content.original_group_hash, ) === encodeHashToBase64(groupHash) ) { peerIsTyping.set(false); if (timeout) clearTimeout(timeout); } } }); return peerIsTyping; }), )"
            },
            {
              "kind": "field",
              "name": "privateMessengerEntries",
              "privacy": "private"
            },
            {
              "kind": "field",
              "name": "internalEntries",
              "privacy": "private",
              "default": "new AsyncComputed<InternalEntries>(() => { const privateMessengerEntriesResult = this.privateMessengerEntries.get(); if (privateMessengerEntriesResult.status !== 'completed') return privateMessengerEntriesResult; const allMyAgents = this.allMyAgents.get(); if (allMyAgents.status !== 'completed') return allMyAgents; const allMyAgentsB64 = allMyAgents.value.map(encodeHashToBase64); const privateMessengerEntries = privateMessengerEntriesResult.value; const value: InternalEntries = { privateMessengerEntries, peerChats: {}, groups: {}, }; for (const [entryHash, privateMessengerEntry] of Object.entries( privateMessengerEntries, )) { switch (privateMessengerEntry.signed_content.content.type) { case 'PeerMessage': const peerMessage = privateMessengerEntry as Signed<PeerMessage>; const peer = !allMyAgentsB64.includes( encodeHashToBase64(peerMessage.provenance), ) ? peerMessage.provenance : peerMessage.signed_content.content.recipient; const peerB64 = encodeHashToBase64(peer); if (!value.peerChats[peerB64]) { value.peerChats[peerB64] = { messages: [], myReadMessages: [], theirReadMessages: [], }; } value.peerChats[peerB64].messages.push(entryHash); break; case 'ReadPeerMessages': const readPeerMessages = privateMessengerEntry as Signed<ReadPeerMessages>; const fromMe = allMyAgentsB64.includes( encodeHashToBase64(readPeerMessages.provenance), ); const peer2 = fromMe ? readPeerMessages.signed_content.content.peer : readPeerMessages.provenance; const peerB642 = encodeHashToBase64(peer2); if (!value.peerChats[peerB642]) { value.peerChats[peerB642] = { messages: [], myReadMessages: [], theirReadMessages: [], }; } if (fromMe) { for (const readMessage of readPeerMessages.signed_content.content .read_messages_hashes) { value.peerChats[peerB642].myReadMessages.push( encodeHashToBase64(readMessage), ); } } else { for (const readMessage of readPeerMessages.signed_content.content .read_messages_hashes) { value.peerChats[peerB642].theirReadMessages.push( encodeHashToBase64(readMessage), ); } } break; case 'UpdateGroupChat': const update = privateMessengerEntry as Signed<UpdateGroupChat>; const groupHash = encodeHashToBase64( update.signed_content.content.original_group_hash, ); if (!value.groups[groupHash]) { value.groups[groupHash] = { updates: [], deletes: [], messages: [], myReadMessages: [], theirReadMessages: {}, }; } value.groups[groupHash].updates.push(entryHash); break; case 'DeleteGroupChat': const deleteChat = privateMessengerEntry as Signed<DeleteGroupChat>; const groupHash2 = encodeHashToBase64( deleteChat.signed_content.content.original_group_hash, ); if (!value.groups[groupHash2]) { value.groups[groupHash2] = { updates: [], deletes: [], messages: [], myReadMessages: [], theirReadMessages: {}, }; } value.groups[groupHash2].deletes.push(entryHash); break; case 'GroupMessage': const groupMessage = privateMessengerEntry as Signed<GroupMessage>; const groupHash3 = encodeHashToBase64( groupMessage.signed_content.content.original_group_hash, ); if (!value.groups[groupHash3]) { value.groups[groupHash3] = { updates: [], deletes: [], messages: [], myReadMessages: [], theirReadMessages: {}, }; } value.groups[groupHash3].messages.push(entryHash); break; case 'ReadGroupMessages': const readGroupMessages = privateMessengerEntry as Signed<ReadGroupMessages>; const author = encodeHashToBase64(readGroupMessages.provenance); const fromMe2 = allMyAgentsB64.includes(author); const groupHash4 = encodeHashToBase64( readGroupMessages.signed_content.content.group_hash, ); if (!value.groups[groupHash4]) { value.groups[groupHash4] = { updates: [], deletes: [], messages: [], myReadMessages: [], theirReadMessages: {}, }; } if (fromMe2) { for (const readMessage of readGroupMessages.signed_content.content .read_messages_hashes) { value.groups[groupHash4].myReadMessages.push( encodeHashToBase64(readMessage), ); } } else { for (const readMessage of readGroupMessages.signed_content.content .read_messages_hashes) { if (!value.groups[groupHash4].theirReadMessages[author]) { value.groups[groupHash4].theirReadMessages[author] = []; } value.groups[groupHash4].theirReadMessages[author].push( encodeHashToBase64(readMessage), ); } } break; case 'CreateGroupChat': if (!value.groups[entryHash]) { value.groups[entryHash] = { updates: [], deletes: [], messages: [], myReadMessages: [], theirReadMessages: {}, }; } break; } } return { status: 'completed', value, }; })"
            },
            {
              "kind": "field",
              "name": "allAgentsFor",
              "privacy": "private",
              "default": "new MemoHoloHashMap((agent: AgentPubKey) => { if (this.linkedDevicesStore) { return new AsyncComputed(() => { const devices = this.linkedDevicesStore!.linkedDevicesForAgent.get(agent).get(); if (devices.status !== 'completed') return devices; return { status: 'completed', value: [agent, ...devices.value], }; }); } else { return new AsyncState({ status: 'completed', value: [agent] }); } })"
            },
            {
              "kind": "field",
              "name": "allMyAgents"
            },
            {
              "kind": "field",
              "name": "peerChats",
              "default": "new MemoHoloHashMap( (agent: AgentPubKey) => new AsyncComputed(() => { const messages = this.internalEntries.get(); const myAgents = this.allMyAgents.get(); const theirAgents = this.allAgentsFor.get(agent).get(); if (messages.status !== 'completed') return messages; if (theirAgents.status !== 'completed') return theirAgents; if (myAgents.status !== 'completed') return myAgents; const agentMessages: Record<EntryHashB64, Signed<PeerMessage>> = {}; const theirAgentsB64 = theirAgents.value.map(encodeHashToBase64); const myReadMessages: Array<EntryHashB64> = []; const theirReadMessages: Array<EntryHashB64> = []; for (const agent of theirAgentsB64) { const peerChatForThisAgent = messages.value.peerChats[agent]; if (peerChatForThisAgent) { for (const messageHash of peerChatForThisAgent.messages) { const message = messages.value.privateMessengerEntries[ messageHash ] as Signed<PeerMessage>; agentMessages[messageHash] = message; } for (const readMessageHash of peerChatForThisAgent.myReadMessages) { myReadMessages.push(readMessageHash); } for (const readMessageHash of peerChatForThisAgent.theirReadMessages) { theirReadMessages.push(readMessageHash); } } } let peerIsTyping = false; for (const theirAgent of theirAgents.value) { const thisPeerIsTyping = this.peerIsTyping.get(theirAgent).get(); if (thisPeerIsTyping) { peerIsTyping = true; } } return { status: 'completed', value: { messages: agentMessages, myReadMessages, theirReadMessages, myAgentSet: myAgents.value, theirAgentSet: theirAgents.value, peerIsTyping, }, }; }), )"
            },
            {
              "kind": "field",
              "name": "groupChats",
              "default": "new MemoHoloHashMap( (groupHash: EntryHash) => new AsyncComputed(() => { const privateMessengerEntries = this.internalEntries.get(); if (privateMessengerEntries.status !== 'completed') return privateMessengerEntries; const myAgents = this.allMyAgents.get(); if (myAgents.status !== 'completed') return myAgents; const groupHashB64 = encodeHashToBase64(groupHash); const group = privateMessengerEntries.value.groups[groupHashB64]; if (!group) { return { status: 'completed', value: undefined, }; } const originalGroup = privateMessengerEntries.value .privateMessengerEntries[groupHashB64] as Signed<Group>; let currentGroup: Group = originalGroup.signed_content.content; let currentGroupTimestamp = originalGroup.signed_content.timestamp; const messages: Record<EntryHashB64, Signed<GroupMessage>> = {}; const updates: Record<EntryHashB64, Signed<UpdateGroupChat>> = {}; const deletes: Record<EntryHashB64, Signed<DeleteGroupChat>> = {}; let theirAgents: AgentPubKey[] = []; for (const updateHash of group.updates) { const update = privateMessengerEntries.value.privateMessengerEntries[ updateHash ] as Signed<UpdateGroupChat>; updates[updateHash] = update; if (currentGroupTimestamp < update.signed_content.timestamp) { currentGroupTimestamp = update.signed_content.timestamp; currentGroup = update.signed_content.content.group; } theirAgents.push(update.provenance); } for (const messageHash of group.messages) { const message = privateMessengerEntries.value.privateMessengerEntries[ messageHash ] as Signed<GroupMessage>; messages[messageHash] = message; theirAgents.push(message.provenance); } for (const deleteHash of group.deletes) { const deleteChat = privateMessengerEntries.value .privateMessengerEntries[deleteHash] as Signed<DeleteGroupChat>; deletes[deleteHash] = deleteChat; theirAgents.push(deleteChat.provenance); } for (const admin of currentGroup.admins) { theirAgents.push(admin); } for (const member of currentGroup.members) { theirAgents.push(member); } theirAgents = uniquify(theirAgents).filter( theirAgent => !myAgents.value.find( myAgent => encodeHashToBase64(myAgent) === encodeHashToBase64(theirAgent), ), ); const agentsLinkedDevices = joinAsyncMap( mapValues(slice(this.allAgentsFor, theirAgents), s => s.get()), ); if (agentsLinkedDevices.status !== 'completed') return agentsLinkedDevices; const theirAgentSets: Array<Array<AgentPubKey>> = []; for (const agents of Array.from(agentsLinkedDevices.value.values())) { const currentAgentSet = theirAgentSets.findIndex(agentSet => agentSet.find(agent => agents.find( a => encodeHashToBase64(a) === encodeHashToBase64(agent), ), ), ); if (currentAgentSet === -1) { theirAgentSets.push(agents); } else { theirAgentSets[currentAgentSet] = uniquify([ ...theirAgentSets[currentAgentSet], ...agents, ]); } } const typingPeers: Array<AgentPubKey> = []; for (const agentSet of theirAgentSets) { for (const agent of agentSet) { const isTyping = this.peerIsTypingInGroup .get(groupHash) .get(agent) .get(); if (isTyping) typingPeers.push(agent); } } return { status: 'completed', value: { originalGroup, currentGroup, messages, updates, deletes, myAgentSet: myAgents.value, theirAgentSets, typingPeers, myReadMessages: group.myReadMessages, }, }; }), )"
            },
            {
              "kind": "field",
              "name": "allPeerChats",
              "default": "new AsyncComputed<Array<PeerChat>>(() => { const privateMessengerEntries = this.internalEntries.get(); if (privateMessengerEntries.status !== 'completed') return privateMessengerEntries; const myAgents = this.allMyAgents.get(); if (myAgents.status !== 'completed') return myAgents; let allPeerAgents: AgentPubKey[] = Object.keys( privateMessengerEntries.value.peerChats, ).map(decodeHashFromBase64); const linkedDevicesForAllPeerAgents = joinAsyncMap( mapValues(slice(this.allAgentsFor, allPeerAgents), s => s.get()), ); if (linkedDevicesForAllPeerAgents.status !== 'completed') return linkedDevicesForAllPeerAgents; const agentSets: Array<Array<AgentPubKeyB64>> = []; for (const [agent, agents] of Array.from( linkedDevicesForAllPeerAgents.value.entries(), )) { const agentSetForAgentIndex = agentSets.findIndex( a => !!agents.find(a2 => a.includes(encodeHashToBase64(a2))), ); if (agentSetForAgentIndex === -1) { agentSets.push(agents.map(encodeHashToBase64)); } else { agentSets[agentSetForAgentIndex] = Array.from( new Set([ ...agentSets[agentSetForAgentIndex], ...agents.map(encodeHashToBase64), ]), ); } } const peerChats: Array<PeerChat> = []; for (const agentSet of agentSets) { let lastActivity: Signed<PeerMessage> | undefined; const myReadMessages: Record<EntryHashB64, 'read' | 'unread'> = {}; for (const agent of agentSet) { const peerChatForAgent = privateMessengerEntries.value.peerChats[agent]; if (peerChatForAgent) { for (const messageHash of peerChatForAgent.messages) { const message = privateMessengerEntries.value .privateMessengerEntries[messageHash] as Signed<PeerMessage>; if ( !lastActivity || lastActivity.signed_content.timestamp < message.signed_content.timestamp ) { lastActivity = message; } const fromMe = myAgents.value.find( myAgent => encodeHashToBase64(myAgent) === encodeHashToBase64(message.provenance), ); if (!fromMe && !myReadMessages[messageHash]) { myReadMessages[messageHash] = 'unread'; } } for (const readMessageHash of peerChatForAgent.myReadMessages) { myReadMessages[readMessageHash] = 'read'; } } } const myUnreadMessages = Object.entries(myReadMessages) .filter(([_, read]) => read === 'unread') .map(([hash, _]) => decodeHashFromBase64(hash)); if (lastActivity) { peerChats.push({ theirAgentSet: agentSet.map(decodeHashFromBase64), lastActivity, myUnreadMessages, }); } } return { status: 'completed', value: peerChats, }; })"
            },
            {
              "kind": "field",
              "name": "allGroupChats",
              "default": "new AsyncComputed<Array<GroupChat>>(() => { const privateMessengerEntries = this.internalEntries.get(); if (privateMessengerEntries.status !== 'completed') return privateMessengerEntries; const myAgents = this.allMyAgents.get(); if (myAgents.status !== 'completed') return myAgents; const myAgentsB64 = myAgents.value.map(encodeHashToBase64); const chats: Array<GroupChat> = []; for (const [groupHash, group] of Object.entries( privateMessengerEntries.value.groups, )) { const createGroup = privateMessengerEntries.value.privateMessengerEntries[ groupHash ] as Signed<{ type: 'CreateGroupChat' } & Group>; let lastActivity: GroupMessengerEntry = createGroup; let lastGroupVersion: [Timestamp, Group] = [ createGroup.signed_content.timestamp, createGroup.signed_content.content, ]; const myUnreadMessages: EntryHash[] = []; for (const messageHash of group.messages) { const message = privateMessengerEntries.value.privateMessengerEntries[messageHash]; if ( lastActivity.signed_content.timestamp < message.signed_content.timestamp ) { lastActivity = message as Signed< { type: 'GroupMessage' } & GroupMessage >; } if ( !myAgentsB64.includes(encodeHashToBase64(message.provenance)) && !group.myReadMessages.includes(messageHash) ) { myUnreadMessages.push(decodeHashFromBase64(messageHash)); } } for (const updateHash of group.updates) { const update = privateMessengerEntries.value.privateMessengerEntries[ updateHash ] as Signed<{ type: 'UpdateGroupChat' } & UpdateGroupChat>; if ( lastActivity.signed_content.timestamp < update.signed_content.timestamp ) { lastActivity = update; } if (lastGroupVersion[0] < update.signed_content.timestamp) { lastGroupVersion = [ update.signed_content.timestamp, update.signed_content.content.group, ]; } } for (const deleteHash of group.deletes) { const deleteGroup = privateMessengerEntries.value .privateMessengerEntries[deleteHash] as Signed< { type: 'DeleteGroupChat' } & DeleteGroupChat >; lastActivity = deleteGroup; } chats.push({ lastActivity, currentGroup: lastGroupVersion[1], groupHash: decodeHashFromBase64(groupHash), myUnreadMessages, }); } return { status: 'completed', value: chats, }; })"
            },
            {
              "kind": "field",
              "name": "allChats",
              "default": "new AsyncComputed<Array<Chat>>(() => { const allGroupChats = this.allGroupChats.get(); const allPeerChats = this.allPeerChats.get(); if (allGroupChats.status !== 'completed') return allGroupChats; if (allPeerChats.status !== 'completed') return allPeerChats; const groupChats = allGroupChats.value.map(g => ({ type: 'GroupChat' as const, ...g, })); const peerChats = allPeerChats.value.map(p => ({ type: 'PeerChat' as const, ...p, })); const chats = [...groupChats, ...peerChats].sort( (c1, c2) => c2.lastActivity.signed_content.timestamp - c1.lastActivity.signed_content.timestamp, ); return { status: 'completed', value: chats, }; })"
            }
          ]
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "MessengerStore",
          "declaration": {
            "name": "MessengerStore",
            "module": "src/messenger-store.ts"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "src/mocks.ts",
      "declarations": [
        {
          "kind": "class",
          "description": "",
          "name": "MessengerZomeMock",
          "superclass": {
            "name": "ZomeMock",
            "package": "@tnesh-stack/utils"
          }
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "MessengerZomeMock",
          "declaration": {
            "name": "MessengerZomeMock",
            "module": "src/mocks.ts"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "src/styles.ts",
      "declarations": [
        {
          "kind": "variable",
          "name": "messengerStyles",
          "type": {
            "text": "array"
          },
          "default": "[ ...sharedStyles, css` .message { border-radius: 4px; border: 1px solid lightgrey; padding: 4px; box-shadow: rgba(149, 157, 165, 0.2) 2px 2px 4px; background-color: var(--sl-color-neutral-100, white); } .from-me { right: 0; } .from-me .message { background-color: var(--sl-color-primary-600, blue); align-self: end; color: var(--sl-color-neutral-0, white); } .from-me .message sl-relative-time { color: var(--sl-color-neutral-100, white); } .from-me .message sl-format-date { color: var(--sl-color-neutral-100, white); } .from-me .message span { color: var(--sl-color-neutral-100, white); } .typing-indicator { display: flex; flex-direction: row; align-items: end; border-radius: 4px; height: 16px; padding: 0 4px; background: var(--sl-color-neutral-300); color: var(--sl-color-neutral-500); font-size: 24px; } `, ]"
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "messengerStyles",
          "declaration": {
            "name": "messengerStyles",
            "module": "src/styles.ts"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "src/types.ts",
      "declarations": [],
      "exports": []
    },
    {
      "kind": "javascript-module",
      "path": "src/utils.ts",
      "declarations": [
        {
          "kind": "function",
          "name": "asyncReadable",
          "parameters": [
            {
              "name": "initFn",
              "type": {
                "text": "(set: (value: T) => void) => Promise<(() => void) | void>"
              }
            }
          ]
        },
        {
          "kind": "variable",
          "name": "TYPING_INDICATOR_TTL_MS"
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "asyncReadable",
          "declaration": {
            "name": "asyncReadable",
            "module": "src/utils.ts"
          }
        },
        {
          "kind": "js",
          "name": "TYPING_INDICATOR_TTL_MS",
          "declaration": {
            "name": "TYPING_INDICATOR_TTL_MS",
            "module": "src/utils.ts"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "src/elements/all-chats.ts",
      "declarations": [
        {
          "kind": "class",
          "description": "",
          "name": "AllChats",
          "members": [
            {
              "kind": "field",
              "name": "store",
              "type": {
                "text": "MessengerStore"
              }
            },
            {
              "kind": "field",
              "name": "profilesStore",
              "type": {
                "text": "ProfilesStore"
              }
            },
            {
              "kind": "method",
              "name": "renderPeerChat",
              "parameters": [
                {
                  "name": "chat",
                  "type": {
                    "text": "PeerChat"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "renderTime",
              "parameters": [
                {
                  "name": "timestamp",
                  "type": {
                    "text": "Timestamp"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "renderAgentNickname",
              "parameters": [
                {
                  "name": "agent",
                  "type": {
                    "text": "AgentPubKey"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "renderGroupLastActivity",
              "parameters": [
                {
                  "name": "groupMessengerEntry",
                  "type": {
                    "text": "GroupMessengerEntry"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "renderGroupChat",
              "parameters": [
                {
                  "name": "groupHash",
                  "type": {
                    "text": "EntryHash"
                  }
                },
                {
                  "name": "group",
                  "type": {
                    "text": "Group"
                  }
                },
                {
                  "name": "lastActivity",
                  "type": {
                    "text": "GroupMessengerEntry"
                  }
                },
                {
                  "name": "myUnreadMessages",
                  "type": {
                    "text": "EntryHash[]"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "renderChats",
              "parameters": [
                {
                  "name": "chats",
                  "type": {
                    "text": "Array<Chat>"
                  }
                }
              ]
            }
          ],
          "events": [
            {
              "name": "peer-chat-selected",
              "type": {
                "text": "CustomEvent"
              }
            },
            {
              "name": "group-chat-selected",
              "type": {
                "text": "CustomEvent"
              }
            }
          ],
          "mixins": [
            {
              "name": "SignalWatcher",
              "package": "@tnesh-stack/signals"
            }
          ],
          "superclass": {
            "name": "LitElement",
            "package": "lit"
          },
          "tagName": "all-chats",
          "customElement": true
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "AllChats",
          "declaration": {
            "name": "AllChats",
            "module": "src/elements/all-chats.ts"
          }
        },
        {
          "kind": "custom-element-definition",
          "name": "all-chats",
          "declaration": {
            "name": "AllChats",
            "module": "src/elements/all-chats.ts"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "src/elements/group-chat.ts",
      "declarations": [
        {
          "kind": "class",
          "description": "",
          "name": "GroupChat",
          "members": [
            {
              "kind": "field",
              "name": "groupHash",
              "type": {
                "text": "EntryHash"
              },
              "attribute": "groupHash"
            },
            {
              "kind": "field",
              "name": "store",
              "type": {
                "text": "MessengerStore"
              }
            },
            {
              "kind": "field",
              "name": "profilesStore",
              "type": {
                "text": "ProfilesStore"
              }
            },
            {
              "kind": "method",
              "name": "renderChat",
              "privacy": "private",
              "parameters": [
                {
                  "name": "myAgents",
                  "type": {
                    "text": "AgentPubKey[]"
                  }
                },
                {
                  "name": "originalGroup",
                  "type": {
                    "text": "Signed<Group>"
                  }
                },
                {
                  "name": "currentGroup",
                  "type": {
                    "text": "Group"
                  }
                },
                {
                  "name": "updates",
                  "type": {
                    "text": "Record<EntryHashB64, Signed<UpdateGroupChat>>"
                  }
                },
                {
                  "name": "deletes",
                  "type": {
                    "text": "Record<EntryHashB64, Signed<DeleteGroupChat>>"
                  }
                },
                {
                  "name": "messages",
                  "type": {
                    "text": "Record<EntryHashB64, Signed<GroupMessage>>"
                  }
                },
                {
                  "name": "theirAgentSets",
                  "type": {
                    "text": "Array<Array<AgentPubKey>>"
                  }
                },
                {
                  "name": "typingPeers",
                  "type": {
                    "text": "Array<AgentPubKey>"
                  }
                },
                {
                  "name": "myReadMessages",
                  "type": {
                    "text": "EntryHashB64[]"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "renderTypingIndicators",
              "privacy": "private",
              "parameters": [
                {
                  "name": "typingPeers",
                  "type": {
                    "text": "Array<AgentPubKey>"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "renderMessageSetFromMe",
              "privacy": "private",
              "parameters": [
                {
                  "name": "messageSet",
                  "type": {
                    "text": "MessageSet<GroupMessage>"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "renderAgentNickname",
              "parameters": [
                {
                  "name": "agent",
                  "type": {
                    "text": "AgentPubKey"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "renderMessageSetToMe",
              "privacy": "private",
              "parameters": [
                {
                  "name": "messageSet",
                  "type": {
                    "text": "MessageSet<GroupMessage>"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "sendMessage",
              "parameters": [
                {
                  "name": "currentGroupHash",
                  "type": {
                    "text": "EntryHash"
                  }
                },
                {
                  "name": "message",
                  "type": {
                    "text": "Message"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "messages"
            }
          ],
          "events": [
            {
              "name": "agent-selected",
              "type": {
                "text": "CustomEvent"
              }
            }
          ],
          "attributes": [
            {
              "name": "groupHash",
              "type": {
                "text": "EntryHash"
              },
              "fieldName": "groupHash"
            }
          ],
          "mixins": [
            {
              "name": "SignalWatcher",
              "package": "@tnesh-stack/signals"
            }
          ],
          "superclass": {
            "name": "LitElement",
            "package": "lit"
          },
          "tagName": "group-chat",
          "customElement": true
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "GroupChat",
          "declaration": {
            "name": "GroupChat",
            "module": "src/elements/group-chat.ts"
          }
        },
        {
          "kind": "custom-element-definition",
          "name": "group-chat",
          "declaration": {
            "name": "GroupChat",
            "module": "src/elements/group-chat.ts"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "src/elements/message-input.ts",
      "declarations": [
        {
          "kind": "class",
          "description": "",
          "name": "MessageInput",
          "members": [
            {
              "kind": "method",
              "name": "dispatchSendMessage",
              "privacy": "private",
              "parameters": [
                {
                  "name": "message",
                  "type": {
                    "text": "string"
                  }
                }
              ]
            }
          ],
          "events": [
            {
              "name": "send-message",
              "type": {
                "text": "CustomEvent"
              }
            }
          ],
          "mixins": [
            {
              "name": "SignalWatcher",
              "package": "@tnesh-stack/signals"
            }
          ],
          "superclass": {
            "name": "LitElement",
            "package": "lit"
          },
          "tagName": "message-input",
          "customElement": true
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "MessageInput",
          "declaration": {
            "name": "MessageInput",
            "module": "src/elements/message-input.ts"
          }
        },
        {
          "kind": "custom-element-definition",
          "name": "message-input",
          "declaration": {
            "name": "MessageInput",
            "module": "src/elements/message-input.ts"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "src/elements/messenger-context.ts",
      "declarations": [
        {
          "kind": "class",
          "description": "",
          "name": "MessengerContext",
          "members": [
            {
              "kind": "field",
              "name": "store",
              "type": {
                "text": "MessengerStore"
              },
              "attribute": "store"
            },
            {
              "kind": "field",
              "name": "client",
              "type": {
                "text": "AppClient"
              }
            },
            {
              "kind": "field",
              "name": "linkedDevicesStore",
              "type": {
                "text": "LinkedDevicesStore"
              }
            },
            {
              "kind": "field",
              "name": "role",
              "type": {
                "text": "string"
              },
              "attribute": "role"
            },
            {
              "kind": "field",
              "name": "zome",
              "type": {
                "text": "string"
              },
              "default": "'messenger'",
              "attribute": "zome"
            }
          ],
          "attributes": [
            {
              "name": "store",
              "type": {
                "text": "MessengerStore"
              },
              "fieldName": "store"
            },
            {
              "name": "role",
              "type": {
                "text": "string"
              },
              "fieldName": "role"
            },
            {
              "name": "zome",
              "type": {
                "text": "string"
              },
              "default": "'messenger'",
              "fieldName": "zome"
            }
          ],
          "superclass": {
            "name": "LitElement",
            "package": "lit"
          },
          "tagName": "messenger-context",
          "customElement": true
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "MessengerContext",
          "declaration": {
            "name": "MessengerContext",
            "module": "src/elements/messenger-context.ts"
          }
        },
        {
          "kind": "custom-element-definition",
          "name": "messenger-context",
          "declaration": {
            "name": "MessengerContext",
            "module": "src/elements/messenger-context.ts"
          }
        }
      ]
    },
    {
      "kind": "javascript-module",
      "path": "src/elements/peer-chat.ts",
      "declarations": [
        {
          "kind": "class",
          "description": "",
          "name": "PeerChat",
          "members": [
            {
              "kind": "field",
              "name": "peer",
              "type": {
                "text": "AgentPubKey"
              },
              "attribute": "peer"
            },
            {
              "kind": "field",
              "name": "store",
              "type": {
                "text": "MessengerStore"
              }
            },
            {
              "kind": "method",
              "name": "renderTypingIndicator",
              "privacy": "private"
            },
            {
              "kind": "method",
              "name": "renderChat",
              "privacy": "private",
              "parameters": [
                {
                  "name": "messages",
                  "type": {
                    "text": "Record<EntryHashB64, Signed<PeerMessage>>"
                  }
                },
                {
                  "name": "myAgents",
                  "type": {
                    "text": "AgentPubKey[]"
                  }
                },
                {
                  "name": "theirAgents",
                  "type": {
                    "text": "AgentPubKey[]"
                  }
                },
                {
                  "name": "peerIsTyping",
                  "type": {
                    "text": "boolean"
                  }
                },
                {
                  "name": "myReadMessages",
                  "type": {
                    "text": "Array<EntryHashB64>"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "renderMessageSet",
              "privacy": "private",
              "parameters": [
                {
                  "name": "messageSet",
                  "type": {
                    "text": "MessageSet<PeerMessage>"
                  }
                },
                {
                  "name": "myAgentsB64",
                  "type": {
                    "text": "AgentPubKeyB64[]"
                  }
                }
              ]
            },
            {
              "kind": "method",
              "name": "sendMessage",
              "parameters": [
                {
                  "name": "message",
                  "type": {
                    "text": "Message"
                  }
                }
              ]
            }
          ],
          "attributes": [
            {
              "name": "peer",
              "type": {
                "text": "AgentPubKey"
              },
              "fieldName": "peer"
            }
          ],
          "mixins": [
            {
              "name": "SignalWatcher",
              "package": "@tnesh-stack/signals"
            }
          ],
          "superclass": {
            "name": "LitElement",
            "package": "lit"
          },
          "tagName": "peer-chat",
          "customElement": true
        }
      ],
      "exports": [
        {
          "kind": "js",
          "name": "PeerChat",
          "declaration": {
            "name": "PeerChat",
            "module": "src/elements/peer-chat.ts"
          }
        },
        {
          "kind": "custom-element-definition",
          "name": "peer-chat",
          "declaration": {
            "name": "PeerChat",
            "module": "src/elements/peer-chat.ts"
          }
        }
      ]
    }
  ]
}
